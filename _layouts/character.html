---
layout: default
---

<div class="character-detail">
  <!-- Back Button Container for Centering -->
  <div class="back-btn-container" style="text-align: center; margin-bottom: 1rem;">
    <button class="back-select-btn" onclick="window.history.back();">
      Back to Character Selection
    </button>
  </div>

  <div class="detail-container">
    <!-- Left Panel: Character Background/Abilities -->
    <div class="left-panel">
      {{ content }}
    </div>

    <!-- Right Panel: Character Image and Basic Info -->
    <div class="right-panel">
      <div class="image-container">
        <img src="{{ page.image }}" alt="{{ page.title }}" id="character-pfp" style="cursor: zoom-in;">
      </div>
      <div class="basic-info">
        {% if page.age %}<p><strong>Age:</strong> {{ page.age }}</p>{% endif %}
        {% if page.birthday %}<p><strong>Birthday:</strong> {{ page.birthday }}</p>{% endif %}
        {% if page.species %}<p><strong>Species:</strong> {{ page.species }}</p>{% endif %}
        {% if page.gender %}<p><strong>Gender:</strong> {{ page.gender }}</p>{% endif %}
        {% if page.height %}<p><strong>Height:</strong> {{ page.height }}</p>{% endif %}
        {% if page.weight %}<p><strong>Weight:</strong> {{ page.weight }}</p>{% endif %}
        {% if page.cup_size %}<p><strong>Cup Size:</strong> {{ page.cup_size }}</p>{% endif %}
        {% if page.mana_color %}<p><strong>Mana Color:</strong> {{ page.mana_color }}</p>{% endif %}
        {% if page.hair_color %}<p><strong>Hair color:</strong> {{ page.hair_color }}</p>{% endif %}
        {% if page.eye_color %}<p><strong>Eye color:</strong> {{ page.eye_color }}</p>{% endif %}
        {% if page.credit %}<p><strong>Picture Credit:</strong> {{ page.credit }}</p>{% endif %}
      </div>
    </div>
  </div>
</div>

<!-- ========================= -->
<!-- Gallery Lightbox Overlay  -->
<!-- ========================= -->
<div class="gallery-overlay" aria-hidden="true" style="display:none;">
  <div class="gallery-backdrop"></div>
  <div class="gallery-modal" role="dialog" aria-modal="true" aria-label="Image gallery">
    <div class="gallery-stage">
      <!-- Move Close button INSIDE the stage so it's always tappable -->
      <button class="gallery-btn gallery-close" aria-label="Close (Esc)">&times;</button>

      <div class="gallery-viewport" aria-label="Image viewport">
        <img class="gallery-image" alt="" draggable="false">
      </div>

      <!-- UI Controls -->
      <div class="gallery-controls">
        <button class="gallery-btn gallery-prev" aria-label="Previous (←)">&#10094;</button>
        <div class="gallery-zoom">
          <button class="gallery-btn gallery-zoom-out" aria-label="Zoom out">−</button>
          <button class="gallery-btn gallery-zoom-reset" aria-label="Reset zoom">1:1</button>
          <button class="gallery-btn gallery-zoom-in" aria-label="Zoom in">+</button>
        </div>
        <button class="gallery-btn gallery-next" aria-label="Next (→)">&#10095;</button>
      </div>

      <div class="gallery-counter" aria-live="polite"></div>
    </div>
  </div>
</div>

<style>
  /* ===== Lightbox Base (scoped) ===== */
  .gallery-overlay {
    position: fixed;
    inset: 0;
    z-index: 9999;
  }
  .gallery-backdrop {
    position: absolute;
    inset: 0;
    background: rgba(0,0,0,0.7);
  }
  .gallery-modal {
    position: absolute;
    inset: 0;
    display: grid;
    place-items: center;
    /* IMPORTANT: allow taps/clicks inside modal (fixes mobile close button) */
    pointer-events: auto;
  }

  .gallery-stage {
    width: 60vw;       /* desktop width */
    height: 95vh;      /* tall vertical space */
    background: rgba(17,17,17,0.4); /* 40% transparent black */
    border-radius: 12px;
    box-shadow: 0 10px 40px rgba(0,0,0,0.5);
    position: relative;
    overflow: hidden;
    pointer-events: auto;
  }

  /* ✅ Mobile/tablet responsive override */
  @media (max-width: 1280px) {
    .gallery-stage {
      width: 100vw;    /* full width on smaller screens */
      height: 90vh;    /* 5% shorter to account for mobile browser UI */
      border-radius: 0; /* fullscreen feel */
    }
  }

  .gallery-close {
    position: absolute;
    top: 12px;
    right: 16px;
    font-size: 28px;
    line-height: 1;
    background: rgba(0,0,0,0.45);
    color: #fff;
    border: none;
    border-radius: 10px;
    padding: 10px 14px;       /* larger tap target */
    cursor: pointer;
    z-index: 3;
    touch-action: manipulation; /* faster taps on mobile */
  }

  .gallery-viewport {
    position: absolute;
    inset: 48px 0 56px 0;
    overflow: hidden;
    touch-action: none;   /* we handle pan/pinch ourselves */
    user-select: none;
    cursor: grab;
  }
  .gallery-viewport.grabbing { cursor: grabbing; }

  .gallery-image {
    position: absolute;
    left: 50%;
    top: 50%;
    width: auto;
    height: auto;
    max-width: none;
    max-height: none;
    transform-origin: center center;
    will-change: transform;
    pointer-events: none;
    user-select: none;
    -webkit-user-drag: none;
  }

  .gallery-controls {
    position: absolute;
    left: 0;
    right: 0;
    bottom: 8px;
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 6px 10px;
    gap: 10px;
  }
  .gallery-btn {
    background: rgba(0,0,0,0.5);
    color: #fff;
    border: 1px solid rgba(255,255,255,0.25);
    border-radius: 8px;
    padding: 8px 12px;
    cursor: pointer;
    transition: background 0.15s ease;
  }
  .gallery-btn:hover { background: rgba(0,0,0,0.7); }

  .gallery-prev, .gallery-next {
    font-size: 18px;
    min-width: 44px;
  }
  .gallery-zoom {
    display: flex;
    align-items: center;
    gap: 8px;
  }

  .gallery-counter {
    position: absolute;
    top: 12px;
    left: 16px;
    color: #fff;
    font-size: 14px;
    background: rgba(0,0,0,0.45);
    padding: 4px 8px;
    border-radius: 6px;
  }

  .character-detail .right-panel .image-container img#character-pfp { display: block; }
</style>

<script>
(function(){
  const GALLERY = ({% if page.gallery and page.gallery.size > 0 %}[{% for url in page.gallery %}"{{ url | escape }}"{% unless forloop.last %},{% endunless %}{% endfor %}]{% else %}[] {% endif %});
  if (!GALLERY.length) return;

  const pfp = document.getElementById('character-pfp');
  const overlay = document.querySelector('.gallery-overlay');
  const backdrop = document.querySelector('.gallery-backdrop');
  const viewport = document.querySelector('.gallery-viewport');
  const img = document.querySelector('.gallery-image');
  const btnClose = document.querySelector('.gallery-close');
  const btnPrev = document.querySelector('.gallery-prev');
  const btnNext = document.querySelector('.gallery-next');
  const btnZoomIn = document.querySelector('.gallery-zoom-in');
  const btnZoomOut = document.querySelector('.gallery-zoom-out');
  const btnZoomReset = document.querySelector('.gallery-zoom-reset');
  const counter = document.querySelector('.gallery-counter');

  let index = 0;

  // Zoom & pan state
  let scale0 = 1;   // fitted baseline (computed per image)
  let scale = 1;    // current scale (relative to fitted)
  const minScale = 1, maxScale = 6;
  let pos = { x: 0, y: 0 };
  let isPanning = false;
  let start = { x: 0, y: 0 };

  // Gesture helpers
  let isPinching = false;
  let pinchStartDist = 0;
  let pinchStartScale = 1;
  let pinchMid = { x: 0, y: 0 };
  let tapTimer = 0;
  const DOUBLE_TAP_MS = 280;

  // Swipe helpers (when not zoomed)
  let touchStartX = 0, touchStartY = 0, touchStartTime = 0;

  img.ondragstart = () => false;

  function updateCounter(){ counter.textContent = (index+1)+" / "+GALLERY.length; }

  function computeFitScale(){
    const rect = viewport.getBoundingClientRect();
    const iw = img.naturalWidth||1, ih = img.naturalHeight||1;
    const heightFit = rect.height / ih;
    const widthFit  = rect.width  / iw;
    scale0 = Math.min(heightFit, widthFit);  // contain (no crop), height-first intention
  }

  function applyTransform(){
    img.style.transform =
      `translate(-50%, -50%) translate(${pos.x}px, ${pos.y}px) scale(${scale0*scale})`;
  }

  function clampPan(){
    const rect = viewport.getBoundingClientRect();
    const iw = (img.naturalWidth||1) * scale0 * scale;
    const ih = (img.naturalHeight||1) * scale0 * scale;
    const halfW = Math.max(0,(iw-rect.width)/2);
    const halfH = Math.max(0,(ih-rect.height)/2);
    pos.x = Math.min(halfW, Math.max(-halfW,pos.x));
    pos.y = Math.min(halfH, Math.max(-halfH,pos.y));
  }

  function centerImage(){ pos={x:0,y:0}; }

  function loadImage(i){
    index=(i+GALLERY.length)%GALLERY.length;
    img.src=GALLERY[index];
    img.onload=function(){
      computeFitScale();
      scale=1; centerImage();
      applyTransform();
      updateCounter();
    };
  }

  function openOverlay(startIndex=0){
    overlay.style.display='block';
    overlay.setAttribute('aria-hidden','false');
    loadImage(startIndex);
    document.documentElement.style.overflow='hidden';
  }
  function closeOverlay(){
    overlay.style.display='none';
    overlay.setAttribute('aria-hidden','true');
    document.documentElement.style.overflow='';
  }

  function zoomAt(deltaY,clientX,clientY){
    const prev=scale;
    const next=deltaY<0?scale*1.1:scale/1.1; // inverted: wheel up => zoom in
    scale=Math.max(minScale,Math.min(maxScale,next));
    const rect=viewport.getBoundingClientRect();
    const cx=clientX-rect.left-rect.width/2-pos.x;
    const cy=clientY-rect.top-rect.height/2-pos.y;
    const ratio=scale/prev;
    pos.x-=cx*(ratio-1);
    pos.y-=cy*(ratio-1);
    clampPan(); applyTransform();
  }

  // Maintain visual zoom after orientation/resize
  window.addEventListener('resize',()=>{
    if(overlay.getAttribute('aria-hidden')==='true')return;
    const currentAbs=scale0*scale;
    computeFitScale();
    scale=Math.max(minScale,Math.min(maxScale,currentAbs/scale0));
    clampPan(); applyTransform();
  });

  // Open/Close hooks
  pfp.addEventListener('click',()=>openOverlay(0));
  btnClose.addEventListener('click',closeOverlay);
  backdrop.addEventListener('click',closeOverlay);

  // Buttons
  btnPrev.addEventListener('click',()=>loadImage(index-1));
  btnNext.addEventListener('click',()=>loadImage(index+1));
  btnZoomIn.addEventListener('click',()=>{scale=Math.min(maxScale,scale*1.2);clampPan();applyTransform();});
  btnZoomOut.addEventListener('click',()=>{scale=Math.max(minScale,scale/1.2);clampPan();applyTransform();});
  btnZoomReset.addEventListener('click',()=>{computeFitScale();scale=1;centerImage();applyTransform();});

  // Keyboard
  window.addEventListener('keydown',e=>{
    if(overlay.getAttribute('aria-hidden')==='true')return;
    if(e.key==='Escape')closeOverlay();
    if(e.key==='ArrowLeft')loadImage(index-1);
    if(e.key==='ArrowRight')loadImage(index+1);
  });

  /* =========================
     Pointer & Touch Gestures
     ========================= */

  // Helpers
  function distance(t1, t2){
    const dx = t1.clientX - t2.clientX;
    const dy = t1.clientY - t2.clientY;
    return Math.hypot(dx, dy);
  }
  function midpoint(t1, t2){
    return { x: (t1.clientX + t2.clientX)/2, y: (t1.clientY + t2.clientY)/2 };
  }

  // Double-tap to toggle zoom (1 -> 2 -> 1)
  function handleDoubleTap(e){
    const now = Date.now();
    if (now - tapTimer < DOUBLE_TAP_MS) {
      // toggle between fitted(1) and ~2x
      const prev = scale;
      scale = scale > 1 ? 1 : 2;
      // zoom around tap point
      const rect = viewport.getBoundingClientRect();
      const cx = (e.changedTouches ? e.changedTouches[0].clientX : e.clientX) - rect.left - rect.width/2 - pos.x;
      const cy = (e.changedTouches ? e.changedTouches[0].clientY : e.clientY) - rect.top - rect.height/2 - pos.y;
      const ratio = scale / prev;
      pos.x -= cx * (ratio - 1);
      pos.y -= cy * (ratio - 1);
      clampPan(); applyTransform();
    }
    tapTimer = now;
  }

  // Touch start
  viewport.addEventListener('touchstart', (e) => {
    if (e.touches.length === 2) {
      // Begin pinch
      isPinching = true;
      isPanning = false;
      const [t1, t2] = e.touches;
      pinchStartDist = distance(t1, t2);
      pinchStartScale = scale;
      pinchMid = midpoint(t1, t2);
    } else if (e.touches.length === 1) {
      // Possible pan or swipe or double-tap
      handleDoubleTap(e);
      const t = e.touches[0];
      if (scale > 1) {
        isPanning = true;
        viewport.classList.add('grabbing');
        e.preventDefault();
        start.x = t.clientX - pos.x;
        start.y = t.clientY - pos.y;
      } else {
        // track swipe when not zoomed
        touchStartX = t.clientX;
        touchStartY = t.clientY;
        touchStartTime = Date.now();
      }
    }
  }, { passive: false });

  // Touch move
  viewport.addEventListener('touchmove', (e) => {
    if (isPinching && e.touches.length === 2) {
      e.preventDefault();
      const [t1, t2] = e.touches;
      const newDist = distance(t1, t2);
      const prev = scale;
      scale = Math.max(minScale, Math.min(maxScale, (newDist / pinchStartDist) * pinchStartScale));

      // Keep pinch midpoint stable
      const rect = viewport.getBoundingClientRect();
      const cx = pinchMid.x - rect.left - rect.width/2 - pos.x;
      const cy = pinchMid.y - rect.top  - rect.height/2 - pos.y;
      const ratio = scale / prev;
      pos.x -= cx * (ratio - 1);
      pos.y -= cy * (ratio - 1);

      clampPan(); applyTransform();
    } else if (isPanning && e.touches.length === 1) {
      e.preventDefault();
      const t = e.touches[0];
      pos.x = t.clientX - start.x;
      pos.y = t.clientY - start.y;
      clampPan(); applyTransform();
    }
  }, { passive: false });

  // Touch end
  viewport.addEventListener('touchend', (e) => {
    if (isPinching && e.touches.length < 2) {
      isPinching = false;
    }
    if (isPanning && e.touches.length === 0) {
      isPanning = false;
      viewport.classList.remove('grabbing');
    }

    // Swipe detection (only when NOT zoomed and not pinching)
    if (!isPinching && scale <= 1 && e.changedTouches && e.changedTouches.length) {
      const t = e.changedTouches[0];
      const dx = t.clientX - touchStartX;
      const dy = t.clientY - touchStartY;
      const dt = Date.now() - touchStartTime;

      // basic swipe: quick, mostly horizontal
      if (dt < 600 && Math.abs(dx) > 50 && Math.abs(dy) < 60) {
        if (dx < 0) {
          // swipe left -> next
          loadImage(index + 1);
        } else {
          // swipe right -> prev
          loadImage(index - 1);
        }
      }
    }
  });

  // Mouse pan / wheel zoom
  function pointerDown(e){
    if (scale <= 1) return; // only pan when zoomed
    isPanning = true;
    viewport.classList.add('grabbing');
    e.preventDefault(); // stop image drag/select
    start.x = e.clientX - pos.x;
    start.y = e.clientY - pos.y;
  }
  function pointerMove(e){
    if (!isPanning) return;
    pos.x = e.clientX - start.x;
    pos.y = e.clientY - start.y;
    clampPan(); applyTransform();
  }
  function pointerUp(){
    isPanning = false;
    viewport.classList.remove('grabbing');
  }

  viewport.addEventListener('mousedown', pointerDown);
  window.addEventListener('mousemove', pointerMove);
  window.addEventListener('mouseup', pointerUp);

  viewport.addEventListener('wheel', e => {
    e.preventDefault();
    zoomAt(e.deltaY, e.clientX, e.clientY);
  }, { passive: false });
})();
</script>
