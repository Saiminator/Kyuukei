---
layout: default
---

<div class="character-detail">
  <!-- Back Button Container for Centering -->
  <div class="back-btn-container" style="text-align: center; margin-bottom: 1rem;">
    <button class="back-select-btn" onclick="window.history.back();">
      Back to Character Selection
    </button>
  </div>
  
  <div class="detail-container">
    <!-- Left Panel: Character Background/Abilities -->
    <div class="left-panel">
      {{ content }}
    </div>

    <!-- Right Panel: Character Image and Basic Info -->
    <div class="right-panel">
      <div class="image-container">
        <!-- Clickable profile image (opens lightbox if gallery exists; PFP is NOT in the slideshow) -->
        <img id="profile-image"
             src="{{ page.image | relative_url }}"
             alt="{{ page.title | escape }}"
             style="cursor: zoom-in; max-width: 100%; height: auto;">
      </div>

      <div class="basic-info">
        {% if page.age %}<p><strong>Age:</strong> {{ page.age }}</p>{% endif %}
        {% if page.birthday %}<p><strong>Birthday:</strong> {{ page.birthday }}</p>{% endif %}
        {% if page.species %}<p><strong>Species:</strong> {{ page.species }}</p>{% endif %}
        {% if page.gender %}<p><strong>Gender:</strong> {{ page.gender }}</p>{% endif %}
        {% if page.height %}<p><strong>Height:</strong> {{ page.height }}</p>{% endif %}
        {% if page.weight %}<p><strong>Weight:</strong> {{ page.weight }}</p>{% endif %}
        {% if page.cup_size %}<p><strong>Cup Size:</strong> {{ page.cup_size }}</p>{% endif %}
        {% if page.mana_color %}<p><strong>Mana Color:</strong> {{ page.mana_color }}</p>{% endif %}
        {% if page.hair_color %}<p><strong>Hair color:</strong> {{ page.hair_color }}</p>{% endif %}
        {% if page.eye_color %}<p><strong>Eye color:</strong> {{ page.eye_color }}</p>{% endif %}
        {% if page.credit %}<p><strong>Picture Credit:</strong> {{ page.credit }}</p>{% endif %}
      </div>
    </div>
  </div>
</div>

{%- comment -%}
Lightbox items come ONLY from page.gallery (profile image is not included).
Supports short form (string) and object form {src, alt}.
{%- endcomment -%}
{% assign gallery = page.gallery %}
<script>
  // Build items from gallery only (no profile image)
  window.__characterLightboxItems = [
    {% if gallery and gallery.size > 0 %}
      {% for item in gallery %}
        {
          {% if item.src %}
            "src": "{{ item.src | relative_url }}",
            "alt": {{ (item.alt | default: page.title) | jsonify }}
          {% else %}
            "src": "{{ item | relative_url }}",
            "alt": {{ page.title | jsonify }}
          {% endif %}
        }{% unless forloop.last %},{% endunless %}
      {% endfor %}
    {% endif %}
  ];
</script>

<!-- LIGHTBOX MARKUP -->
<div id="lb" class="lb" aria-hidden="true">
  <div class="lb-backdrop" data-close></div>

  <div class="lb-content" role="dialog" aria-modal="true" aria-label="Image viewer" tabindex="-1">
    <div class="lb-stage" id="lb-stage">
      <div class="lb-spinner" id="lb-spinner" aria-hidden="true"></div>
      <!-- Transform layer for zoom/pan -->
      <div id="lb-layer" aria-hidden="true">
        <img id="lb-img" src="" alt="" draggable="false" />
      </div>
    </div>
    <div class="lb-footer">
      <figcaption id="lb-caption"></figcaption>
      <button class="lb-btn lb-close" data-close aria-label="Close">&times;</button>
      <button class="lb-btn lb-prev" data-prev aria-label="Previous">&#10094;</button>
      <button class="lb-btn lb-next" data-next aria-label="Next">&#10095;</button>
    </div>
  </div>
</div>

<style>
  /* ===== Global safety & defaults ===== */
  .lb, .lb * { box-sizing: border-box; }
  .lb { position: fixed; inset: 0; display: none; z-index: 1000; }
  .lb[aria-hidden="false"] { display: block; }
  .lb-backdrop { position: absolute; inset: 0; background: rgba(0,0,0,.72); backdrop-filter: blur(2px); }
  #lb-img {
    display: block; margin: 0;
    user-select: none; -webkit-user-drag: none; /* no native drag/selection */
    pointer-events: none; /* events handled on layer */
  }

  /* ===== Lightbox shell uses FLEX on all viewports (robust centering) ===== */
  .lb-content {
    position: absolute; inset: 0;
    display: flex; flex-direction: column;
    align-items: center; justify-content: center;
    padding: 12px;
    width: 100svw; height: 100svh; /* dynamic viewport with fallbacks below */
  }
  @supports not (height: 100svh) {
    .lb-content { width: 100dvw; height: 100dvh; }
  }

  /* Stage: fills available space, perfectly centers, contains overflow */
  .lb-stage {
    position: relative;
    flex: 1 1 auto;
    width: min(98vw, 1400px);
    max-width: 98vw;
    max-height: 92vh;
    display: flex; align-items: center; justify-content: center;
    background: rgba(0,0,0,.22);
    border-radius: .6rem;
    box-shadow: 0 16px 40px rgba(0,0,0,.45);
    overflow: hidden; /* contain zoomed image while panning */
  }

  /* Transform layer is what we scale/translate; image keeps intrinsic fitting */
  #lb-layer {
    touch-action: none; cursor: grab;
    transform: translate(0px, 0px) scale(1);
    transform-origin: center center;
    will-change: transform;
  }
  #lb-layer.panning { cursor: grabbing; }

  /* Base image fit: always fully visible at scale=1 (no crop) */
  #lb-img {
    max-width: 100%;
    max-height: 100%;
    width: auto; height: auto;
    object-fit: contain;
    opacity: 0;
    transition: opacity .12s ease;
  }

  .lb-footer {
    position: relative;
    width: min(98vw, 1400px);
    max-width: 98vw;
    display: grid;
    grid-template-columns: 1fr auto auto auto;
    align-items: center;
    gap: .5rem;
    margin-top: .5rem;
  }

  #lb-caption {
    color: #fff; text-align: left; font-size: .95rem; min-height: 1.2em;
    overflow: hidden; text-overflow: ellipsis; white-space: nowrap;
  }

  .lb-btn {
    background: rgba(0,0,0,.55);
    color: #fff; border: none; border-radius: 999px;
    width: 48px; height: 48px; display: grid; place-items: center;
    font-size: 22px; cursor: pointer; transition: background .15s ease;
  }
  .lb-btn:hover { background: rgba(0,0,0,.8); }
  .lb-close { width: 40px; height: 40px; font-size: 28px; background: rgba(0,0,0,.7); }

  /* Spinner */
  .lb-spinner { position: absolute; inset: 0; display: grid; place-items: center; }
  .lb-spinner::after {
    content: ""; width: 38px; height: 38px; border-radius: 999px;
    border: 3px solid rgba(255,255,255,.35); border-top-color: #fff;
    animation: lbspin 0.8s linear infinite;
  }
  [aria-hidden="true"] > .lb-spinner, .lb-spinner[aria-hidden="true"] { display: none; }
  @keyframes lbspin { to { transform: rotate(360deg); } }

  /* ===== Mobile tweaks (safe-areas, bigger buttons) ===== */
  @media (max-width: 720px) {
    .lb-content {
      padding:
        calc(env(safe-area-inset-top, 0px) + 8px)
        10px
        calc(env(safe-area-inset-bottom, 0px) + 12px);
    }
    .lb-btn { width: 56px; height: 56px; font-size: 24px; }
    .lb-close { position: absolute; top: calc(env(safe-area-inset-top, 0px) + 8px); right: 12px; }
  }
</style>

<script>
(function(){
  const items = (window.__characterLightboxItems || []).filter(Boolean);
  const profileImg = document.getElementById('profile-image');
  if (!profileImg) return;

  const lb         = document.getElementById('lb');
  const stage      = document.getElementById('lb-stage');
  const layer      = document.getElementById('lb-layer');
  const imgEl      = document.getElementById('lb-img');
  const captionEl  = document.getElementById('lb-caption');
  const spinner    = document.getElementById('lb-spinner');

  const btnClose   = document.querySelector('.lb-close');
  const btnPrev    = document.querySelector('.lb-prev');
  const btnNext    = document.querySelector('.lb-next');

  // Zoom/Pan state
  let index = 0;
  let scale = 1;
  const minScale = 1;
  const maxScale = 6;
  let tx = 0, ty = 0;
  let panning = false;
  let startX = 0, startY = 0;

  // pinch helpers
  let pinchStartDist = 0;
  let pinchStartScale = 1;

  function setVisible(vis) {
    lb.setAttribute('aria-hidden', vis ? 'false' : 'true');
    document.body.style.overflow = vis ? 'hidden' : '';
    document.documentElement.style.overscrollBehavior = vis ? 'none' : '';
  }

  function applyTransform() {
    layer.style.transform = `translate(${tx}px, ${ty}px) scale(${scale})`;
  }

  function fitBase() {
    // reset to fit view
    scale = 1; tx = 0; ty = 0;
    applyTransform();
  }

  function clampPan() {
    // keep zoomed image within stage bounds
    const rect = stage.getBoundingClientRect();
    const iw = imgEl.naturalWidth || 1;
    const ih = imgEl.naturalHeight || 1;

    // compute how large the image appears at base fit
    const stageW = rect.width, stageH = rect.height;
    const fitScale = Math.min(stageW / iw, stageH / ih);
    const dispW = iw * fitScale * scale;
    const dispH = ih * fitScale * scale;

    const maxX = Math.max(0, (dispW - stageW) / 2);
    const maxY = Math.max(0, (dispH - stageH) / 2);

    tx = Math.min(maxX, Math.max(-maxX, tx));
    ty = Math.min(maxY, Math.max(-maxY, ty));
  }

  function zoomAt(clientX, clientY, factor) {
    const prev = scale;
    scale = Math.max(minScale, Math.min(maxScale, scale * factor));
    if (scale === prev) return;

    // keep the zoom focus point fixed
    const rect = stage.getBoundingClientRect();
    const cx = clientX - rect.left - rect.width / 2;
    const cy = clientY - rect.top  - rect.height / 2;
    tx = tx - cx * (scale/prev - 1);
    ty = ty - cy * (scale/prev - 1);

    clampPan();
    applyTransform();
  }

  function loadAt(i){
    index = ((i % items.length) + items.length) % items.length;
    const it = items[index];

    spinner.setAttribute('aria-hidden','false');
    imgEl.style.opacity = '0';

    const probe = new Image();
    probe.onload = () => {
      imgEl.src = it.src;
      imgEl.alt = it.alt || '';
      captionEl.textContent = it.alt || '';
      spinner.setAttribute('aria-hidden','true');
      imgEl.style.opacity = '1';
      // base fit (prevents any clipping on any window size)
      fitBase();
    };
    probe.onerror = () => {
      spinner.setAttribute('aria-hidden','true');
      captionEl.textContent = 'Failed to load image';
    };
    probe.src = it.src;
  }

  function openAt(i){
    if (!items.length) return;
    setVisible(true);
    loadAt(i);
    document.querySelector('.lb-content')?.focus();
  }
  function close(){ setVisible(false); imgEl.src=''; }

  function prev(){ loadAt(index - 1); }
  function next(){ loadAt(index + 1); }

  // Open on clicking profile image
  profileImg.addEventListener('click', () => openAt(0));

  // Controls
  btnClose?.addEventListener('click', close);
  btnPrev ?.addEventListener('click', prev);
  btnNext ?.addEventListener('click', next);

  // Backdrop click → close
  lb.addEventListener('click', (e) => {
    if (e.target.classList.contains('lb-backdrop')) close();
  });

  // Prevent text/image selection while dragging
  stage.addEventListener('selectstart', (e) => e.preventDefault());
  imgEl.addEventListener('dragstart', (e) => e.preventDefault());

  // Keyboard
  document.addEventListener('keydown', (e) => {
    if (lb.getAttribute('aria-hidden') === 'true') return;
    if (e.key === 'Escape') { e.preventDefault(); close(); }
    else if (e.key === 'ArrowLeft')  { e.preventDefault(); prev(); }
    else if (e.key === 'ArrowRight') { e.preventDefault(); next(); }
    else if (e.key === '+') { e.preventDefault(); zoomAt(window.innerWidth/2, window.innerHeight/2, 1.15); }
    else if (e.key === '-') { e.preventDefault(); zoomAt(window.innerWidth/2, window.innerHeight/2, 1/1.15); }
    else if (e.key === '0') { e.preventDefault(); fitBase(); }
  });

  // Wheel zoom
  stage.addEventListener('wheel', (e) => {
    if (lb.getAttribute('aria-hidden') === 'true') return;
    e.preventDefault();
    const factor = e.deltaY > 0 ? (1/1.15) : 1.15;
    zoomAt(e.clientX, e.clientY, factor);
  }, { passive: false });

  // Double-click / double-tap toggle
  let lastTap = 0;
  stage.addEventListener('dblclick', (e) => {
    e.preventDefault();
    if (scale === 1) zoomAt(e.clientX, e.clientY, 2.0);
    else fitBase();
  });
  stage.addEventListener('touchend', (e) => {
    const now = Date.now();
    if (now - lastTap < 300) {
      const t = e.changedTouches[0];
      if (scale === 1) zoomAt(t.clientX, t.clientY, 2.0);
      else fitBase();
    }
    lastTap = now;
  }, { passive: true });

  // Pointer-based pan
  stage.addEventListener('pointerdown', (e) => {
    if (lb.getAttribute('aria-hidden') === 'true') return;
    // Only start panning if zoomed in (scale > 1); otherwise let clicks go
    if (scale <= 1) return;
    e.preventDefault();
    panning = true;
    layer.classList.add('panning');
    startX = e.clientX - tx;
    startY = e.clientY - ty;
    stage.setPointerCapture(e.pointerId);
  });
  stage.addEventListener('pointermove', (e) => {
    if (!panning) return;
    e.preventDefault();
    tx = e.clientX - startX;
    ty = e.clientY - startY;
    clampPan();
    applyTransform();
  });
  function endPan(e){
    if (!panning) return;
    panning = false;
    layer.classList.remove('panning');
    try { stage.releasePointerCapture(e.pointerId); } catch(_) {}
  }
  stage.addEventListener('pointerup', endPan);
  stage.addEventListener('pointercancel', endPan);
  stage.addEventListener('lostpointercapture', () => { panning = false; layer.classList.remove('panning'); });

  // Pinch zoom (two fingers)
  stage.addEventListener('touchstart', (e) => {
    if (e.touches.length === 2) {
      pinchStartDist = Math.hypot(
        e.touches[0].clientX - e.touches[1].clientX,
        e.touches[0].clientY - e.touches[1].clientY
      );
      pinchStartScale = scale;
    }
  }, { passive: true });
  stage.addEventListener('touchmove', (e) => {
    if (e.touches.length === 2) {
      e.preventDefault();
      const dist = Math.hypot(
        e.touches[0].clientX - e.touches[1].clientX,
        e.touches[0].clientY - e.touches[1].clientY
      );
      const factor = dist / (pinchStartDist || dist);
      const newScale = Math.max(minScale, Math.min(maxScale, pinchStartScale * factor));

      const rect = stage.getBoundingClientRect();
      const centerX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
      const centerY = (e.touches[0].clientY + e.touches[1].clientY) / 2;

      // keep pinch center fixed
      const prev = scale;
      scale = newScale;
      const cx = centerX - rect.left - rect.width / 2;
      const cy = centerY - rect.top  - rect.height / 2;
      tx = tx - cx * (scale/prev - 1);
      ty = ty - cy * (scale/prev - 1);

      clampPan();
      applyTransform();
    }
  }, { passive: false });

  // Refit on resize / half-screen changes
  window.addEventListener('resize', () => {
    if (lb.getAttribute('aria-hidden') === 'true') return;
    if (scale === 1) fitBase(); else { clampPan(); applyTransform(); }
  });

  // Open on profile click only if there is a gallery
  if (items.length) {
    profileImg.addEventListener('click', () => openAt(0));
  } else {
    // no gallery -> do nothing
  }
})();
</script>
