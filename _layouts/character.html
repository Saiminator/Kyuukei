---
layout: default
---

<div class="character-detail">
  <!-- Back Button Container for Centering -->
  <div class="back-btn-container" style="text-align: center; margin-bottom: 1rem;">
    <button class="back-select-btn" onclick="window.history.back();">
      Back to Character Selection
    </button>
  </div>
  
  <div class="detail-container">
    <!-- Left Panel: Character Background/Abilities -->
    <div class="left-panel">
      {{ content }}
    </div>

    <!-- Right Panel: Character Image and Basic Info -->
    <div class="right-panel">
      <div class="image-container">
        <!-- Clickable profile image (opens lightbox if gallery exists; PFP is NOT in the slideshow) -->
        <img id="profile-image"
             src="{{ page.image | relative_url }}"
             alt="{{ page.title | escape }}"
             style="cursor: zoom-in; max-width: 100%; height: auto;">
      </div>

      <div class="basic-info">
        {% if page.age %}<p><strong>Age:</strong> {{ page.age }}</p>{% endif %}
        {% if page.birthday %}<p><strong>Birthday:</strong> {{ page.birthday }}</p>{% endif %}
        {% if page.species %}<p><strong>Species:</strong> {{ page.species }}</p>{% endif %}
        {% if page.gender %}<p><strong>Gender:</strong> {{ page.gender }}</p>{% endif %}
        {% if page.height %}<p><strong>Height:</strong> {{ page.height }}</p>{% endif %}
        {% if page.weight %}<p><strong>Weight:</strong> {{ page.weight }}</p>{% endif %}
        {% if page.cup_size %}<p><strong>Cup Size:</strong> {{ page.cup_size }}</p>{% endif %}
        {% if page.mana_color %}<p><strong>Mana Color:</strong> {{ page.mana_color }}</p>{% endif %}
        {% if page.hair_color %}<p><strong>Hair color:</strong> {{ page.hair_color }}</p>{% endif %}
        {% if page.eye_color %}<p><strong>Eye color:</strong> {{ page.eye_color }}</p>{% endif %}
        {% if page.credit %}<p><strong>Picture Credit:</strong> {{ page.credit }}</p>{% endif %}
      </div>
    </div>
  </div>
</div>

{%- comment -%}
Lightbox items come ONLY from page.gallery (profile image is not included).
Supports short form (string) and object form {src, alt}.
{%- endcomment -%}
{% assign gallery = page.gallery %}
<script>
  // Build items from gallery only (no profile image)
  window.__characterLightboxItems = [
    {% if gallery and gallery.size > 0 %}
      {% for item in gallery %}
        {
          {% if item.src %}
            "src": "{{ item.src | relative_url }}",
            "alt": {{ (item.alt | default: page.title) | jsonify }}
          {% else %}
            "src": "{{ item | relative_url }}",
            "alt": {{ page.title | jsonify }}
          {% endif %}
        }{% unless forloop.last %},{% endunless %}
      {% endfor %}
    {% endif %}
  ];
</script>

<!-- LIGHTBOX MARKUP -->
<div id="lb" class="lb" aria-hidden="true">
  <div class="lb-backdrop" data-close></div>

  <figure class="lb-content" role="dialog" aria-modal="true" aria-label="Image viewer" tabindex="-1">
    <div class="lb-stage" id="lb-stage">
      <div class="lb-spinner" id="lb-spinner" aria-hidden="true"></div>
      <!-- Wrap the image in a transform layer so we can scale/translate cleanly -->
      <div id="lb-layer">
        <img id="lb-img" src="" alt="" />
      </div>
    </div>
    <figcaption id="lb-caption"></figcaption>

    <button class="lb-btn lb-close" data-close aria-label="Close">&times;</button>
    <button class="lb-btn lb-prev" data-prev aria-label="Previous">&#10094;</button>
    <button class="lb-btn lb-next" data-next aria-label="Next">&#10095;</button>
  </figure>
</div>

<style>
  /* Global safety */
  .lb, .lb * { box-sizing: border-box; }
  #lb-img { margin: 0; display: block; }

  .lb { position: fixed; inset: 0; display: none; z-index: 1000; }
  .lb[aria-hidden="false"] { display: block; }

  .lb-backdrop {
    position: absolute; inset: 0;
    background: rgba(0,0,0,.70);
    backdrop-filter: blur(2px);
  }

  /* ====== DESKTOP / LARGE ====== */
  .lb-content {
    position: absolute;
    left: 50%; top: 50%;
    transform: translate(-50%, -50%);
    max-width: min(98vw, 1400px);
    max-height: 96vh;
    display: grid;
    grid-template-rows: 1fr auto;
    gap: .5rem;
    z-index: 1;
    outline: none;
  }

  .lb-stage {
    position: relative;
    width: 100%;
    height: auto;
    min-height: 40vh; /* ensure usable stage when very short */
    display: grid; place-items: center;
    background: rgba(0,0,0,.25);
    border-radius: .6rem;
    box-shadow: 0 16px 40px rgba(0,0,0,.45);
    overflow: hidden; /* contain the zoomed image while panning */
  }

  /* Transform layer we scale/translate (keeps image sizing rules intact) */
  #lb-layer {
    transform: translate(0px, 0px) scale(1);
    transform-origin: center center;
    will-change: transform;
    touch-action: none; /* allow custom pinch/drag */
  }

  /* Base image sizing: always fit inside stage at scale=1 */
  #lb-img {
    max-width: 98vw;
    max-height: 90vh;
    width: auto;
    height: auto;
    object-fit: contain; /* never crop */
    opacity: 0;
    transition: opacity .15s ease;
    pointer-events: none; /* pointer goes to layer for dragging */
  }

  #lb-caption {
    color: #fff;
    text-align: center;
    font-size: .95rem;
    min-height: 1.2em;
  }

  .lb-btn {
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
    background: rgba(0,0,0,.55);
    color: #fff;
    border: none;
    width: 48px; height: 48px;
    border-radius: 999px;
    display: grid; place-items: center;
    font-size: 22px;
    cursor: pointer;
    transition: background .15s ease;
    z-index: 2;
  }
  .lb-btn:hover { background: rgba(0,0,0,.8); }

  .lb-close {
    top: -20px; right: -20px; transform: none;
    width: 40px; height: 40px; font-size: 28px;
    background: rgba(0,0,0,.7);
  }
  .lb-prev { left: -64px; }
  .lb-next { right: -64px; }

  .lb-spinner {
    position: absolute; inset: 0;
    display: grid; place-items: center;
    background: transparent;
  }
  .lb-spinner::after {
    content: "";
    width: 38px; height: 38px;
    border-radius: 999px;
    border: 3px solid rgba(255,255,255,.35);
    border-top-color: #fff;
    animation: lbspin 0.8s linear infinite;
  }
  [aria-hidden="true"] > .lb-spinner,
  .lb-spinner[aria-hidden="true"] { display: none; }
  @keyframes lbspin { to { transform: rotate(360deg); } }

  /* ====== MOBILE OVERRIDES ====== */
  @media (max-width: 720px) {
    .lb-content {
      position: fixed;
      inset: 0;
      transform: none;
      width: 100dvw;
      height: 100dvh;
      max-width: 100dvw;
      max-height: 100dvh;
      padding:
        calc(env(safe-area-inset-top, 0px) + 10px)
        12px
        calc(env(safe-area-inset-bottom, 0px) + 12px);
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin: 0 auto;
    }

    .lb-stage {
      flex: 1 1 auto;
      width: 100%;
      height: auto;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 0;
      box-shadow: none;
      background: rgba(0,0,0,.15);
      overflow: hidden;
    }

    #lb-img {
      max-width: 100%;
      max-height: 100%;
    }

    .lb-btn {
      width: 56px; height: 56px;
      font-size: 24px;
      background: rgba(0,0,0,.55);
    }
    .lb-prev { left: 10px; top: 50%; transform: translateY(-50%); }
    .lb-next { right: 10px; top: 50%; transform: translateY(-50%); }

    .lb-close {
      position: absolute;
      top: calc(env(safe-area-inset-top, 0px) + 8px);
      right: 10px;
      width: 44px; height: 44px;
      font-size: 28px;
      transform: none;
      background: rgba(0,0,0,.7);
      border-radius: 999px;
    }
  }
</style>

<script>
(function(){
  const items = (window.__characterLightboxItems || []).filter(Boolean);
  const profileImg = document.getElementById('profile-image');
  if (!profileImg) return;

  const lb         = document.getElementById('lb');
  const stage      = document.getElementById('lb-stage');
  const layer      = document.getElementById('lb-layer');
  const imgEl      = document.getElementById('lb-img');
  const captionEl  = document.getElementById('lb-caption');
  const spinner    = document.getElementById('lb-spinner');

  const btnCloseEls = lb.querySelectorAll('[data-close]');
  const btnPrev     = lb.querySelector('[data-prev]');
  const btnNext     = lb.querySelector('[data-next]');

  // Zoom/Pan state
  let index = 0;
  let scale = 1;
  let minScale = 1;
  let maxScale = 6;         // cap zoom
  let tx = 0, ty = 0;       // translation in px
  let isPanning = false;
  let startX = 0, startY = 0;

  // Pinch support
  let pinchStartDist = 0;
  let pinchStartScale = 1;

  function setAriaVisible(vis) {
    lb.setAttribute('aria-hidden', vis ? 'false' : 'true');
    document.body.style.overflow = vis ? 'hidden' : '';
    if (vis) document.documentElement.style.overscrollBehavior = 'none';
    else document.documentElement.style.overscrollBehavior = '';
  }

  function applyTransform() {
    layer.style.transform = `translate(${tx}px, ${ty}px) scale(${scale})`;
  }

  function clampPan() {
    // Clamp translation so image stays within stage bounds at current scale
    const rect = stage.getBoundingClientRect();
    const iw = imgEl.naturalWidth;
    const ih = imgEl.naturalHeight;
    if (!iw || !ih) return;

    // Compute the fitted size (scale=1) the image is rendered at (object-fit: contain)
    const stageW = rect.width, stageH = rect.height;
    const fitScale = Math.min(stageW / iw, stageH / ih);
    const displayW = iw * fitScale * scale;
    const displayH = ih * fitScale * scale;

    // When image is smaller than stage, keep centered (no pan)
    const maxX = Math.max(0, (displayW - stageW) / 2);
    const maxY = Math.max(0, (displayH - stageH) / 2);

    tx = Math.min(maxX, Math.max(-maxX, tx));
    ty = Math.min(maxY, Math.max(-maxY, ty));
  }

  function resetView() {
    scale = 1;
    tx = 0; ty = 0;
    applyTransform();
  }

  function zoomAt(stageX, stageY, deltaScale) {
    const prevScale = scale;
    scale = Math.max(minScale, Math.min(maxScale, scale * deltaScale));
    if (scale === prevScale) return;

    // Keep the point under cursor stationary: adjust translation
    const rect = stage.getBoundingClientRect();
    const cx = stageX - rect.left - rect.width / 2;   // cursor from center
    const cy = stageY - rect.top  - rect.height / 2;

    tx = tx - cx * (scale/prevScale - 1);
    ty = ty - cy * (scale/prevScale - 1);

    clampPan();
    applyTransform();
  }

  function loadAt(i){
    index = ((i % items.length) + items.length) % items.length;
    const it = items[index];

    spinner.setAttribute('aria-hidden','false');
    imgEl.style.opacity = '0';

    const img = new Image();
    img.onload = () => {
      imgEl.src = it.src;
      imgEl.alt = it.alt || '';
      captionEl.textContent = it.alt || '';
      spinner.setAttribute('aria-hidden','true');
      imgEl.style.opacity = '1';

      // After image is ready, reset view to fit
      resetView();
    };
    img.onerror = () => {
      spinner.setAttribute('aria-hidden','true');
      captionEl.textContent = 'Failed to load image';
    };
    img.src = it.src;
  }

  function openAt(i){
    if (!items.length) return; // no gallery => do nothing
    setAriaVisible(true);
    loadAt(i);
    lb.querySelector('.lb-content')?.focus();
  }
  function close(){
    setAriaVisible(false);
    imgEl.src = '';
  }
  function prev(){ loadAt(index - 1); }
  function next(){ loadAt(index + 1); }

  // Click profile image → open at first gallery image (index 0)
  profileImg.addEventListener('click', () => openAt(0));

  // Controls
  btnPrev?.addEventListener('click', prev);
  btnNext?.addEventListener('click', next);
  btnCloseEls.forEach(b => b.addEventListener('click', close));

  // Backdrop click to close
  lb.addEventListener('click', (e) => {
    if (e.target.classList.contains('lb-backdrop')) close();
  });

  // Keyboard: Esc/Left/Right, +/- zoom
  document.addEventListener('keydown', (e) => {
    if (lb.getAttribute('aria-hidden') === 'true') return;
    if (e.key === 'Escape') { e.preventDefault(); close(); }
    else if (e.key === 'ArrowLeft')  { e.preventDefault(); prev(); }
    else if (e.key === 'ArrowRight') { e.preventDefault(); next(); }
    else if (e.key === '+') { e.preventDefault(); zoomAt(window.innerWidth/2, window.innerHeight/2, 1.15); }
    else if (e.key === '-') { e.preventDefault(); zoomAt(window.innerWidth/2, window.innerHeight/2, 1/1.15); }
    else if (e.key === '0') { e.preventDefault(); resetView(); }
  });

  // Wheel zoom (trackpads, mice)
  stage.addEventListener('wheel', (e) => {
    if (lb.getAttribute('aria-hidden') === 'true') return;
    e.preventDefault();
    const delta = e.deltaY;
    const factor = delta > 0 ? (1/1.15) : 1.15;
    zoomAt(e.clientX, e.clientY, factor);
  }, { passive: false });

  // Double-click/tap to toggle zoom
  let lastTap = 0;
  stage.addEventListener('dblclick', (e) => {
    e.preventDefault();
    if (scale === 1) zoomAt(e.clientX, e.clientY, 2.0);
    else resetView();
  });
  stage.addEventListener('touchend', (e) => {
    const now = Date.now();
    if (now - lastTap < 300) {
      // double tap
      const t = e.changedTouches[0];
      if (scale === 1) zoomAt(t.clientX, t.clientY, 2.0);
      else resetView();
    }
    lastTap = now;
  }, { passive: true });

  // Drag to pan (when zoomed)
  stage.addEventListener('pointerdown', (e) => {
    if (lb.getAttribute('aria-hidden') === 'true') return;
    if (e.pointerType === 'touch' && e.isPrimary === false) return;
    isPanning = true;
    startX = e.clientX - tx;
    startY = e.clientY - ty;
    stage.setPointerCapture(e.pointerId);
  });
  stage.addEventListener('pointermove', (e) => {
    if (!isPanning) return;
    tx = e.clientX - startX;
    ty = e.clientY - startY;
    clampPan();
    applyTransform();
  });
  stage.addEventListener('pointerup', (e) => {
    isPanning = false;
    stage.releasePointerCapture(e.pointerId);
  });
  stage.addEventListener('pointercancel', () => { isPanning = false; });

  // Pinch zoom (two-finger)
  stage.addEventListener('touchstart', (e) => {
    if (e.touches.length === 2) {
      pinchStartDist = Math.hypot(
        e.touches[0].clientX - e.touches[1].clientX,
        e.touches[0].clientY - e.touches[1].clientY
      );
      pinchStartScale = scale;
    }
  }, { passive: true });
  stage.addEventListener('touchmove', (e) => {
    if (e.touches.length === 2) {
      e.preventDefault();
      const dist = Math.hypot(
        e.touches[0].clientX - e.touches[1].clientX,
        e.touches[0].clientY - e.touches[1].clientY
      );
      const factor = dist / (pinchStartDist || dist);
      const newScale = Math.max(minScale, Math.min(maxScale, pinchStartScale * factor));
      const centerX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
      const centerY = (e.touches[0].clientY + e.touches[1].clientY) / 2;
      const prev = scale;
      scale = newScale;

      // Adjust translate to keep zoom center stable
      const rect = stage.getBoundingClientRect();
      const cx = centerX - rect.left - rect.width / 2;
      const cy = centerY - rect.top  - rect.height / 2;
      tx = tx - cx * (scale/prev - 1);
      ty = ty - cy * (scale/prev - 1);

      clampPan();
      applyTransform();
    }
  }, { passive: false });

  // Re-fit on resize/orientation change (fixes half-window clipping)
  window.addEventListener('resize', () => {
    if (lb.getAttribute('aria-hidden') === 'true') return;
    // Keep current zoom if >1, but clamp pan to new bounds; if at base, stay fit
    if (scale === 1) { resetView(); }
    else { clampPan(); applyTransform(); }
  });

  // Backdrop click already handled above
})();
</script>
