---
layout: default
---

<div class="character-detail">
  <!-- Back Button Container for Centering -->
  <div class="back-btn-container" style="text-align: center; margin-bottom: 1rem;">
    <button class="back-select-btn" onclick="window.history.back();">
      Back to Character Selection
    </button>
  </div>

  <div class="detail-container">
    <!-- Left Panel: Character Background/Abilities -->
    <div class="left-panel">
      {{ content }}
    </div>

    <!-- Right Panel: Character Image and Basic Info -->
    <div class="right-panel">
      <div class="image-container">
        <img src="{{ page.image }}" alt="{{ page.title }}" id="character-pfp" style="cursor: zoom-in;" data-cursor="select">
      </div>
      <div class="basic-info">
        {% if page.age %}<p><strong>Age:</strong> {{ page.age }}</p>{% endif %}
        {% if page.birthday %}<p><strong>Birthday:</strong> {{ page.birthday }}</p>{% endif %}
        {% if page.species %}<p><strong>Species:</strong> {{ page.species }}</p>{% endif %}
        {% if page.gender %}<p><strong>Gender:</strong> {{ page.gender }}</p>{% endif %}
        {% if page.height %}<p><strong>Height:</strong> {{ page.height }}</p>{% endif %}
        {% if page.weight %}<p><strong>Weight:</strong> {{ page.weight }}</p>{% endif %}
        {% if page.cup_size %}<p><strong>Cup Size:</strong> {{ page.cup_size }}</p>{% endif %}
        {% if page.mana_color %}<p><strong>Mana Color:</strong> {{ page.mana_color }}</p>{% endif %}
        {% if page.hair_color %}<p><strong>Hair color:</strong> {{ page.hair_color }}</p>{% endif %}
        {% if page.eye_color %}<p><strong>Eye color:</strong> {{ page.eye_color }}</p>{% endif %}
        {% if page.credit %}<p><strong>Picture Credit:</strong> {{ page.credit }}</p>{% endif %}
      </div>
      {% if page.music and page.music.enabled %}
      <div class="character-music" data-audio-src="{{ page.music.src | relative_url }}">
        <p class="music-title">{{ page.music.title }}</p>
        <div class="music-controls">
          <button type="button" class="music-toggle" aria-label="Play audio" data-state="paused">▶</button>
          <div class="music-progress" role="slider" aria-label="Seek through track" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0" tabindex="0">
            <div class="music-progress-fill"></div>
          </div>
        </div>
        <div class="music-time">
          <span class="music-current">0:00</span>
          <span class="music-duration">--:--</span>
        </div>
      </div>
      {% endif %}
    </div>
  </div>
</div>

<!-- ========================= -->
<!-- Gallery Lightbox Overlay  -->
<!-- ========================= -->
<div class="gallery-overlay" aria-hidden="true" style="display:none;">
  <div class="gallery-backdrop"></div>
  <div class="gallery-modal" role="dialog" aria-modal="true" aria-label="Image gallery">
    <div class="gallery-stage">
      <!-- Close button (aligned top-right inside stage) -->
      <button class="gallery-btn gallery-close" aria-label="Close (Esc)">&times;</button>

      <div class="gallery-viewport" aria-label="Image viewport">
        <img class="gallery-image" alt="" draggable="false">
      </div>

      <!-- UI Controls -->
      <div class="gallery-controls">
        <button class="gallery-btn gallery-prev" aria-label="Previous (←)">&#10094;</button>
        <div class="gallery-zoom">
          <button class="gallery-btn gallery-zoom-out" aria-label="Zoom out">−</button>
          <button class="gallery-btn gallery-zoom-reset" aria-label="Reset zoom">1:1</button>
          <button class="gallery-btn gallery-zoom-in" aria-label="Zoom in">+</button>
        </div>
        <button class="gallery-btn gallery-next" aria-label="Next (→)">&#10095;</button>
      </div>

      <div class="gallery-counter" aria-live="polite"></div>
    </div>
  </div>
</div>

<style>
  /* ===== Lightbox Base (scoped) ===== */
  .gallery-overlay {
    position: fixed;
    inset: 0;
    z-index: 9999;
  }
  .gallery-backdrop {
    position: absolute;
    inset: 0;
    background: rgba(0,0,0,0.7);
  }
  .gallery-modal {
    position: absolute;
    inset: 0;
    display: grid;
    place-items: center;
    pointer-events: auto;
  }

  .gallery-stage {
    width: 60vw;
    height: 100vh;   /* full vertical on desktop */
    background: rgba(17,17,17,0.4); /* 40% transparent black */
    border-radius: 12px;
    box-shadow: 0 10px 40px rgba(0,0,0,0.5);
    position: relative;
    overflow: hidden;
    pointer-events: auto;
  }

  /* ✅ Mobile/tablet responsive override */
  @media (max-width: 1280px) {
    .gallery-stage {
      width: 100vw;
      height: 90vh;   /* shorter to avoid mobile URL bar */
      border-radius: 0;
    }
  }

  .gallery-close {
    position: absolute;   /* inside stage */
    top: 12px;
    right: 16px;
    font-size: 22px;
    line-height: 1;
    background: rgba(0,0,0,0.55);
    color: #fff;
    border: none;
    border-radius: 6px;
    padding: 6px 10px;
    cursor: pointer;
    z-index: 2;
    touch-action: manipulation;
  }

  .gallery-viewport {
    position: absolute;
    inset: 48px 0 56px 0;
    overflow: hidden;
    touch-action: none; /* we handle pan/pinch ourselves */
    user-select: none;
    cursor: grab;
  }
  .gallery-viewport.grabbing { cursor: grabbing; }

  .gallery-image {
  position: absolute;
  left: 50%;
  top: 50%;
  width: auto;
  height: auto;
  max-width: none;
  max-height: none;
  transform-origin: center center;
  will-change: transform;
  user-select: none;
  -webkit-user-drag: none;
}


  .gallery-controls {
    position: absolute;
    left: 0;
    right: 0;
    bottom: 8px;
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 6px 10px;
    gap: 10px;
  }
  .gallery-btn {
    background: rgba(0,0,0,0.5);
    color: #fff;
    border: 1px solid rgba(255,255,255,0.25);
    border-radius: 8px;
    padding: 8px 12px;
    cursor: pointer;
    transition: background 0.15s ease;
  }
  .gallery-btn:hover { background: rgba(0,0,0,0.7); }

  .gallery-prev, .gallery-next {
    font-size: 18px;
    min-width: 44px;
  }
  .gallery-zoom {
    display: flex;
    align-items: center;
    gap: 8px;
  }

  .gallery-counter {
    position: absolute;
    top: 12px;
    left: 16px;
    color: #fff;
    font-size: 14px;
    background: rgba(0,0,0,0.45);
    padding: 4px 8px;
    border-radius: 6px;
  }

  /* Keep existing page layout intact */
  .character-detail .right-panel .image-container img#character-pfp { display: block; }
</style>

<script>
(function(){
  // Pull gallery URLs from front matter
  const GALLERY = ({% if page.gallery and page.gallery.size > 0 %}[{% for url in page.gallery %}"{{ url | escape }}"{% unless forloop.last %},{% endunless %}{% endfor %}]{% else %}[] {% endif %});
  if (!GALLERY.length) return;

  // Elements
  const pfp = document.getElementById('character-pfp');
  const overlay = document.querySelector('.gallery-overlay');
  const backdrop = document.querySelector('.gallery-backdrop');
  const modal = document.querySelector('.gallery-modal');
  const viewport = document.querySelector('.gallery-viewport');
  const img = document.querySelector('.gallery-image');
  const btnClose = document.querySelector('.gallery-close');
  const btnPrev = document.querySelector('.gallery-prev');
  const btnNext = document.querySelector('.gallery-next');
  const btnZoomIn = document.querySelector('.gallery-zoom-in');
  const btnZoomOut = document.querySelector('.gallery-zoom-out');
  const btnZoomReset = document.querySelector('.gallery-zoom-reset');
  const counter = document.querySelector('.gallery-counter');

  // State
  let index = 0;
  let scale0 = 1;        // fitted baseline scale (per image)
  let scale = 1;         // relative scale
  const minScale = 1, maxScale = 6;
  let pos = { x: 0, y: 0 };
  let isPanning = false;
  let start = { x: 0, y: 0 };

  // Gesture helpers
  let isPinching = false;
  let pinchStartDist = 0;
  let pinchStartScale = 1;
  let pinchMid = { x: 0, y: 0 };
  let tapTimer = 0;
  const DOUBLE_TAP_MS = 280;

  // Swipe helpers (when not zoomed)
  let touchStartX = 0, touchStartY = 0, touchStartTime = 0;

  img.ondragstart = () => false;

  function updateCounter(){ counter.textContent = (index+1) + ' / ' + GALLERY.length; }

  // Fit image by height-first but contain overall (no cropping)
  function computeFitScale(){
    const rect = viewport.getBoundingClientRect();
    const iw = img.naturalWidth  || 1;
    const ih = img.naturalHeight || 1;
    const heightFit = rect.height / ih;
    const widthFit  = rect.width  / iw;
    scale0 = Math.min(heightFit, widthFit);
  }

  function applyTransform(){
    img.style.transform = 'translate(-50%, -50%) translate(' + pos.x + 'px, ' + pos.y + 'px) scale(' + (scale0 * scale) + ')';
  }

  function clampPan(){
    const rect = viewport.getBoundingClientRect();
    const iw = (img.naturalWidth  || 1) * scale0 * scale;
    const ih = (img.naturalHeight || 1) * scale0 * scale;
    const halfW = Math.max(0, (iw - rect.width) / 2);
    const halfH = Math.max(0, (ih - rect.height) / 2);
    pos.x = Math.min(halfW, Math.max(-halfW, pos.x));
    pos.y = Math.min(halfH, Math.max(-halfH, pos.y));
  }

  function centerImage(){ pos.x = 0; pos.y = 0; }

  function loadImage(i){
    index = (i + GALLERY.length) % GALLERY.length;
    img.src = GALLERY[index];
    img.onload = function(){
      computeFitScale();
      scale = 1;
      centerImage();
      applyTransform();
      updateCounter();
    };
  }

  function openOverlay(startIndex=0){
    overlay.style.display = 'block';
    overlay.setAttribute('aria-hidden', 'false');
    loadImage(startIndex);
    document.documentElement.style.overflow = 'hidden';
  }

  function closeOverlay(){
    overlay.style.display = 'none';
    overlay.setAttribute('aria-hidden', 'true');
    document.documentElement.style.overflow = '';
  }

  function zoomAt(deltaY, clientX, clientY){
    const prev = scale;
    const next = (deltaY < 0) ? scale * 1.1 : scale / 1.1; // inverted: wheel up => zoom in
    scale = Math.max(minScale, Math.min(maxScale, next));
    const rect = viewport.getBoundingClientRect();
    const cx = clientX - rect.left - rect.width  / 2 - pos.x;
    const cy = clientY - rect.top  - rect.height / 2 - pos.y;
    const ratio = scale / prev;
    pos.x -= cx * (ratio - 1);
    pos.y -= cy * (ratio - 1);
    clampPan();
    applyTransform();
  }

  // Maintain visual zoom after resize/orientation change
  window.addEventListener('resize', function(){
    if (overlay.getAttribute('aria-hidden') === 'true') return;
    const currentAbs = scale0 * scale;
    computeFitScale();
    scale = Math.max(minScale, Math.min(maxScale, currentAbs / scale0));
    clampPan();
    applyTransform();
  });

  // Open/close hooks
  pfp.addEventListener('click', function(){ openOverlay(0); });
  btnClose.addEventListener('click', function(){ closeOverlay(); });
  backdrop.addEventListener('click', function(){ closeOverlay(); });

  // ✅ Close when clicking outside the stage anywhere in the modal
  modal.addEventListener('click', function(e){
    if (!e.target.closest('.gallery-stage')) {
      closeOverlay();
    }
  });

  // Buttons
  btnPrev.addEventListener('click', function(){ loadImage(index - 1); });
  btnNext.addEventListener('click', function(){ loadImage(index + 1); });
  btnZoomIn.addEventListener('click', function(){ scale = Math.min(maxScale, scale * 1.2); clampPan(); applyTransform(); });
  btnZoomOut.addEventListener('click', function(){ scale = Math.max(minScale, scale / 1.2); clampPan(); applyTransform(); });
  btnZoomReset.addEventListener('click', function(){ computeFitScale(); scale = 1; centerImage(); applyTransform(); });

  // Keyboard
  window.addEventListener('keydown', function(e){
    if (overlay.getAttribute('aria-hidden') === 'true') return;
    if (e.key === 'Escape') closeOverlay();
    if (e.key === 'ArrowLeft') loadImage(index - 1);
    if (e.key === 'ArrowRight') loadImage(index + 1);
  });

  // Gesture helpers
  function distance(t1, t2){
    const dx = t1.clientX - t2.clientX;
    const dy = t1.clientY - t2.clientY;
    return Math.hypot(dx, dy);
  }
  function midpoint(t1, t2){
    return { x: (t1.clientX + t2.clientX)/2, y: (t1.clientY + t2.clientY)/2 };
  }

  // Double-tap to toggle zoom
  function handleDoubleTap(e){
    const now = Date.now();
    if (now - tapTimer < DOUBLE_TAP_MS) {
      const prev = scale;
      scale = (scale > 1) ? 1 : 2;
      const rect = viewport.getBoundingClientRect();
      const pt = e.changedTouches ? e.changedTouches[0] : e;
      const cx = pt.clientX - rect.left - rect.width  / 2 - pos.x;
      const cy = pt.clientY - rect.top  - rect.height / 2 - pos.y;
      const ratio = scale / prev;
      pos.x -= cx * (ratio - 1);
      pos.y -= cy * (ratio - 1);
      clampPan();
      applyTransform();
    }
    tapTimer = now;
  }

  /* =========================
     Touch: pinch, swipe, pan
     ========================= */
  viewport.addEventListener('touchstart', function(e){
    if (e.touches.length === 2) {
      isPinching = true;
      isPanning = false;
      const t1 = e.touches[0], t2 = e.touches[1];
      pinchStartDist = distance(t1, t2);
      pinchStartScale = scale;
      pinchMid = midpoint(t1, t2);
    } else if (e.touches.length === 1) {
      handleDoubleTap(e);
      const t = e.touches[0];
      if (scale > 1) {
        isPanning = true;
        viewport.classList.add('grabbing');
        e.preventDefault();
        start.x = t.clientX - pos.x;
        start.y = t.clientY - pos.y;
      } else {
        touchStartX = t.clientX;
        touchStartY = t.clientY;
        touchStartTime = Date.now();
      }
    }
  }, { passive: false });

  viewport.addEventListener('touchmove', function(e){
    if (isPinching && e.touches.length === 2) {
      e.preventDefault();
      const t1 = e.touches[0], t2 = e.touches[1];
      const newDist = distance(t1, t2);
      const prev = scale;
      scale = Math.max(minScale, Math.min(maxScale, (newDist / pinchStartDist) * pinchStartScale));
      const rect = viewport.getBoundingClientRect();
      const cx = pinchMid.x - rect.left - rect.width  / 2 - pos.x;
      const cy = pinchMid.y - rect.top  - rect.height / 2 - pos.y;
      const ratio = scale / prev;
      pos.x -= cx * (ratio - 1);
      pos.y -= cy * (ratio - 1);
      clampPan();
      applyTransform();
    } else if (isPanning && e.touches.length === 1) {
      e.preventDefault();
      const t = e.touches[0];
      pos.x = t.clientX - start.x;
      pos.y = t.clientY - start.y;
      clampPan();
      applyTransform();
    }
  }, { passive: false });

  viewport.addEventListener('touchend', function(e){
    if (isPinching && e.touches.length < 2) {
      isPinching = false;
    }
    if (isPanning && e.touches.length === 0) {
      isPanning = false;
      viewport.classList.remove('grabbing');
    }
    // Swipe (only when not zoomed)
    if (!isPinching && scale <= 1 && e.changedTouches && e.changedTouches.length) {
      const t = e.changedTouches[0];
      const dx = t.clientX - touchStartX;
      const dy = t.clientY - touchStartY;
      const dt = Date.now() - touchStartTime;
      if (dt < 600 && Math.abs(dx) > 50 && Math.abs(dy) < 60) {
        if (dx < 0) loadImage(index + 1);
        else loadImage(index - 1);
      }
    }
  });

  /* =========================
     Mouse: pan & wheel zoom
     ========================= */
  function pointerDown(e){
    if (scale <= 1) return;
    isPanning = true;
    viewport.classList.add('grabbing');
    e.preventDefault();
    start.x = e.clientX - pos.x;
    start.y = e.clientY - pos.y;
  }
  function pointerMove(e){
    if (!isPanning) return;
    pos.x = e.clientX - start.x;
    pos.y = e.clientY - start.y;
    clampPan();
    applyTransform();
  }
  function pointerUp(){
    isPanning = false;
    viewport.classList.remove('grabbing');
  }

  viewport.addEventListener('mousedown', pointerDown);
  window.addEventListener('mousemove', pointerMove);
  window.addEventListener('mouseup', pointerUp);

  viewport.addEventListener('wheel', function(e){
    e.preventDefault();
    zoomAt(e.deltaY, e.clientX, e.clientY);
  }, { passive: false });

})();
</script>

<script>
(function(){
  const players = document.querySelectorAll('.character-music');
  if (!players.length) return;

  const formatTime = (sec) => {
    if (!isFinite(sec)) return '--:--';
    const minutes = Math.floor(sec / 60);
    const seconds = Math.floor(sec % 60).toString().padStart(2, '0');
    return `${minutes}:${seconds}`;
  };

  players.forEach((player) => {
    const src = player.dataset.audioSrc;
    if (!src) return;

    const btn = player.querySelector('.music-toggle');
    const progress = player.querySelector('.music-progress');
    const fill = player.querySelector('.music-progress-fill');
    const current = player.querySelector('.music-current');
    const duration = player.querySelector('.music-duration');
    const audio = new Audio(src);
    audio.preload = 'metadata';

    audio.addEventListener('loadedmetadata', () => {
      duration.textContent = formatTime(audio.duration);
    });

    audio.addEventListener('timeupdate', () => {
      const percent = (audio.currentTime / (audio.duration || 1)) * 100;
      fill.style.width = `${percent}%`;
      progress.setAttribute('aria-valuenow', Math.round(percent));
      current.textContent = formatTime(audio.currentTime);
    });

    audio.addEventListener('ended', () => {
      btn.dataset.state = 'paused';
      btn.textContent = '▶';
      fill.style.width = '0%';
      progress.setAttribute('aria-valuenow', 0);
      current.textContent = '0:00';
    });

    btn?.addEventListener('click', () => {
      const isPaused = btn.dataset.state !== 'playing';
      if (isPaused) {
        btn.dataset.state = 'playing';
        btn.textContent = '❚❚';
        audio.play();
      } else {
        btn.dataset.state = 'paused';
        btn.textContent = '▶';
        audio.pause();
      }
    });

    const seekTo = (ratio) => {
      if (!isFinite(audio.duration)) return;
      ratio = Math.max(0, Math.min(1, ratio));
      audio.currentTime = ratio * audio.duration;
    };

    progress?.addEventListener('click', (e) => {
      const rect = progress.getBoundingClientRect();
      const ratio = (e.clientX - rect.left) / rect.width;
      seekTo(ratio);
    });

    progress?.addEventListener('keydown', (e) => {
      if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
        e.preventDefault();
        const delta = e.key === 'ArrowLeft' ? -5 : 5;
        const next = ((audio.currentTime || 0) + delta) / (audio.duration || 1);
        seekTo(next);
      } else if (e.key === 'Home') {
        e.preventDefault();
        seekTo(0);
      } else if (e.key === 'End') {
        e.preventDefault();
        seekTo(1);
      } else if (e.key === ' ' || e.key === 'Spacebar') {
        e.preventDefault();
        btn?.click();
      }
    });
  });
})();
</script>
